<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript数据结构与算法之二叉搜索树]]></title>
      <url>%2FFontEnd%2Fjs-binary-search-tree.html</url>
      <content type="text"><![CDATA[在上一节里我简单介绍了树形结构以及二叉树，这一节就来了解下二叉搜索树（一种特殊的二叉树），在实际应用中二叉搜索树的应用广泛。 二叉搜索树二叉搜索树：它只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。函数构建代码：(普通二叉树类似，利用random函数随机加入左右)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 构造函数function BST() &#123; this.root = null; this.Node = function(key) &#123; this.value = key; // 最好把key处理为数字（懒的写了） this.left = null; this.right = null; &#125;; // add node this.insert = function(key) &#123; // 新建节点 key = new this.Node(key); if (!this.root) &#123; this.root = key; &#125; else &#123; // 根存在 insertNode(this.root, key); &#125; function insertNode(parentNode, newNode) &#123; if (newNode.value &lt; parentNode.value) &#123; // 小于父节点 if (!parentNode.left) &#123; // 左子节点不存在 parentNode.left = newNode; &#125; else &#123; // 左子节点存在 parentNode = parentNode.left; // 父节点换成当前的左节点 return insertNode(parentNode, newNode); // 递归处理 &#125; &#125; else &#123; // 大于父节点 if (!parentNode.right) &#123; parentNode.right = newNode; &#125; else &#123; parentNode = parentNode.right; return insertNode(parentNode, newNode); &#125; &#125; &#125; return this.root; &#125;; // 查找 this.find = function(key) &#123; // 不新建节点也可以，下面比较时就要区分 key = new this.Node(key); if (!this.root) &#123; console.log('root不存在'); return false; &#125; else &#123; // 根存在 findNode(this.root, key); &#125; function findNode(parentNode, newNode) &#123; if (newNode.value &lt; parentNode.value) &#123; // 小于递归查找左边 findNode(parentNode.left, newNode); &#125; else if (newNode.value &gt; parentNode.value) &#123; // 大于递归查找右边 findNode(parentNode.right, newNode); &#125; else &#123; // 等于直接输出 console.log(parentNode); return true; &#125; &#125; &#125;; // 删除 this.delete = function(key) &#123; key = new this.Node(key); if (!this.root) &#123; console.log('root不存在'); return false; &#125; else &#123; delNode(this.root, key); &#125; function delNode(parentNode, newNode) &#123; if (newNode.value &lt; parentNode.value) &#123; // 小于比较左边 if (!parentNode.left)&#123; // 左边不存在 return false; &#125; else &#123; // 左边存在(1.等于输出2.不等于递归) if (parentNode.left.value === newNode.value) &#123; parentNode.left = null; return true; &#125; else &#123; delNode(parentNode.left, newNode); &#125; &#125; &#125; else if (newNode.value &gt; parent.value)&#123; // 大于比较右边 if (!parentNode.right) &#123; return false; &#125; else &#123; if (parentNode.right.value === newNode.value) &#123; parentNode.right = null; return true; &#125; else &#123; delNode(parentNode.right, newNode); &#125; &#125; &#125; else &#123; // 等于直接赋值为空 parentNode = null; return true; &#125; &#125; &#125;; // 如何遍历上一节已经介绍了，这里就不写了，也可以添加其他例如max、min方法。 this.max = function() &#123; return maxNode(this.root); function maxNode(node) &#123; if (node) &#123; while(node.right) &#123; node = node.right; &#125; return node.value; &#125; return false; &#125; &#125;; this.min = function() &#123; return minNode(this.root); function minNode(node) &#123; if (node) &#123; while(node.left) &#123; node = node.left; &#125; return node.value; &#125; return false; &#125; &#125;;&#125;// 测试var tree = new BST();console.time('insert test');tree.insert(75);tree.insert(24);tree.insert(35);tree.insert(21);tree.insert(67);tree.insert(78);tree.insert(85);tree.insert(61);tree.insert(12);tree.insert(59);tree.insert(62);tree.insert(55);tree.insert(53);console.timeEnd('insert test');console.time('find test');tree.find(61);console.timeEnd('find test');console.time('delete test');tree.delete(55);console.timeEnd('delete test'); 参考资料： https://segmentfault.com/a/1190000008244508 https://github.com/qqcome110/web/issues/5 http://www.imooc.com/article/4713]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数据结构与算法之--树的学习]]></title>
      <url>%2FFontEnd%2Fjs-data-structures-algorithms.html</url>
      <content type="text"><![CDATA[最近刷BaiDu-IFE-2017的JavaScript练习了解了树形结构的知识。这里就做一点笔记，作为自己学习的记录。 树在数据结构中,使用树形结构表示数据之间一对多的关系,树形结构是一种非线型结构.定义: 树(Tree)是n(n≥0)个相同数据类型的数据元素的集合.树中的数据元素称为节点(Node)。n=0的树称为空树(Empty Tree)；对于n＞0的任意非空树T有： 有且仅有一个特殊的结点称为树的根(Root)结点，根没有前驱结点； 若n＞1，则除根结点外，其余结点被分成了m(m＞0)个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti(1≤i≤m)本身又是一棵树。树T1，T2，…，Tm称为这棵树的子树(Subtree)。 由树的定义可知，树的定义是递归的，用树来定义树。因此，树（以及二叉树）的许多算法都使用了递归。 树的常用术语： 结点(Node)：表示树中的数据元素。 结点的度(Degree of Node): 节点所拥有的子树的个数。 树的度(Degree of Tree): 树中各节点度的最大值。 叶子结点(Leaf Node)：度为0的结点，也叫终端结点。 分支结点(Branch Node): 度不为0的节点。 树的深度(Depth of Tree)：树中节点的最大层次数。 二叉树树中的每个节点至多能有两个子节点（树的度不大于2）。二叉树有左右之分，不可颠倒。如果把左右节点顺序颠倒则变了另一个全新的二叉树。 有一个二叉树式的html文档，如何遍历：Demo 先序遍历(根左右)12345678910111213141516function preOrder(node) &#123; if (node) &#123; console.log(node); preOrder(node.firstElementChild); preOrder(node.lastElementChild); &#125;&#125;// 二叉树对象var preOrder = function (node) &#123; if (node) &#123; console.log(node.value); preOrder(node.left); preOrder(node.right); &#125;&#125; 中序遍历(左根右)12345678910111213141516function inOrder(node) &#123; if (node) &#123; inOrder(node.firstElementChild); console.log(node); inOrder(node.lastElementChild); &#125;&#125;// 二叉树对象var inOrder = function (node) &#123; if (node) &#123; inOrder(node.left); console.log(node.value); inOrder(node.right); &#125;&#125; 后序遍历(左右根)12345678910111213141516function postOrder(node) &#123; if (node) &#123; postOrder(node.firstElementChild); postOrder(node.lastElementChild); console.log(node); &#125;&#125;// 二叉树对象var postOrder = function (node) &#123; if (node) &#123; postOrder(node.left); postOrder(node.right); console.log(node.value); &#125;&#125; Demo 广度遍历(遍历DOM树而来)12345678910111213//广度function sco(node) &#123; if (node) &#123; var stack = [node]; var target; while(stack.length) &#123; target = stack.shift(); arr.push(target); Array.prototype.push.apply(stack, target.children); // 直接stack.push(target.children)会报错,target.children 是一个数组 &#125; &#125;&#125; 深度遍历(其实效果和先序遍历是一样的)改变unshift,元素从前面加入到stack里面，而取出来的是第一个1234567891011121314151617181920212223242526272829303132333435363738394041//深度(循环)function dep(node) &#123; if (node) &#123; var stack = [node]; var target; while(stack.length) &#123; target = stack.shift(); // 取第一个元素 arr.push(target); Array.prototype.unshift.apply(stack, target.children); &#125; &#125;&#125;// 其他写法（childNodes和firstElementChild的用法）// 递归function rec(node) &#123; if(node &amp;&amp; node.nodeType === 1)&#123; console.log(node); &#125; var i = 0, childNodes = node.childNodes; for(; i &lt; childNodes.length ; i++)&#123; node = childNodes[i]; if(node.nodeType === 1)&#123; //递归先序遍历子节点 rec(node); &#125; &#125;&#125;//递归另一种function walkDom(node, callback) &#123; if (!node) &#123; //判断node是否为null return &#125; callback(node) //将node自身传入callback node = node.firstElementChild //改变node为其子元素节点 while (node) &#123; walkDom(node, callback) //如果存在子元素，则递归调用walkDom node = node.nextElementSibling //从头到尾遍历元素节点 &#125;&#125; 参考资料: https://github.com/Lucifier129/Lucifier129.github.io/issues/4 https://segmentfault.com/a/1190000004620352 https://segmentfault.com/a/1190000000740261 https://juejin.im/entry/5847c17a128fe10058bcf2c5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件绑定、监听及代理学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-event.html</url>
      <content type="text"><![CDATA[事件在JavaScript的学习中，我们经常会遇到JavaScript的事件机制，什么事件捕获、事件冒泡和事件代理（委托）各种专业名词。可以说事件机制在JavaScript中是非常重要的内容，这里就让我们来详细了解下事件机制。 事件绑定在DOM中绑定事件 DOM01234567element.onclick = function(e) &#123;&#125;;// 或者element["onclick"] = function(e) &#123;&#125;;// 其中e表示事件对象ele.onclick = null; // 消除事件 对于同一个dom节点而言，只能注册一个，后边注册的同种事件会覆盖之前注册的。 DOM2 支持同一dom元素注册多个同种事件。 事件捕获和事件冒泡 方法：element.addEventListener(event, listener, useCapture) 和 element.removeEventListener(event, listener, useCapture) event : （必需）事件名，支持所有DOM事件。listener：（必需）指定要事件触发时执行的函数。useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 IE: (event 需要加’on’)ele.attachEvent(event, listener)ele.detachEvent(event, listener) 123456ele.addEventListener('click', fn, false);ele.removeEventListener('click', fn, false);// remove的useCapture必须和add的一样ele.attachEvent('onclick', fn);ele.detachEvent('onclick', fn); 封装事件监听12345678910111213141516171819202122232425//绑定监听事件function addEventHandler(element, event, listener) &#123; if (element.addEventListener) &#123; element.addEventListener(event, listener, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + event, listener); &#125; else &#123; element['on' + event] = listener; &#125;&#125;//移除监听事件function removeEventHandler(element, event, listener)&#123; if (element.removeEventListener) &#123; element.removeEventListener(event, listener, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + event, listener); &#125; else &#123; element['on' + event] = null; &#125;&#125; 事件的捕获和冒泡 W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。 规律：在一个元素上既有捕获又有冒泡，当事件触发时，如果触发元素就是此元素，那么会先捕获后冒泡；如果触发元素是此元素的子元素，那么会按照注册顺序执行。 demo 取消冒泡event.stopPropagation(), IE 是event.cancelBubble = true 事件代理（委托） 父元素绑定事件。 父元素知道事件的实际发生目标是谁。 我们要对目标进行判断，如果是我们需要的元素，则发生回调函数。demo123456789101112131415161718192021222324main.onclick = function () &#123; var e = arguments[0] || window.event; var target = e.target || e.srcElement; if (target.nodeName.toLowerCase() === 'button') &#123; if (target.id === 'left-in') &#123; fn(); &#125; if (target.id === 'right-in') &#123; fn(); &#125; if (target.id === 'left-out') &#123; fn(); &#125; if (target.id === 'right-out') &#123; fn(); &#125; &#125; else if (target.nodeName.toLowerCase() === 'li') &#123; fn1(); &#125;&#125;;// 或者main.addEventListener('click', fn, false); 参考资料: http://www.cnblogs.com/rubylouvre/archive/2009/08/09/1542174.html http://www.cnblogs.com/lhb25/archive/2012/11/30/oninput-and-onpropertychange-event-for-input.html http://yujiangshui.com/javascript-event/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome常用扩展集合]]></title>
      <url>%2FFontEnd%2Fchrome-extension.html</url>
      <content type="text"><![CDATA[Chrome常用扩展集合(持续更新)一键管理所有扩展 对于经常折腾扩展的同志们，就不用担心扩展安装多了，chrome就卡的问题！有了它，轻松管理扩展，暂时不用却又舍不得卸载的扩展，就可以左击一键禁用和启用，右击卸载。 oneTab Chrono下载管理器 Adblock Plus 广告屏蔽插件。 Imagus 图片放大镜的功能！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置 Markdown HereMarkdown 工具 Clear Cache一键清理缓存，开发必备工具。 CSSViewer不用打开控制台就可以查看网站元素的样式。非常方便。 Wappalyzer查看网站服务器组成。以及所用到的技术。 JSON Formatter以更加友好的方式显示JSON数据。 Octotree 以文件列表的形式列出github某个repo下的所有文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript面向对象编程学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-oop.html</url>
      <content type="text"><![CDATA[对每个开发人员来说，面向对象编程都是必须要掌握的技能，但是JavaScript和其他语言不同，因为JavaScript本身不是面向对象的语言，而是基于对象的语言。而ECMAScript中面向对象编程的定义: ECMAScript是基于原型实现的面向对象编程语言。 在面向对象的语言中，我们使用类来创建一个自定义对象。然而JavaScript中几乎所有事物都是对象，那么用什么办法来创建自定义对象呢？ 这就需要引入另外一个概念 - 原型（prototype），我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，给人们的感觉好像是拷贝）。 实例对象来看一个例子：12345678910111213141516//构造函数function Person(name, age, sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125; // 定义Person的原型，原型中的属性可以被自定义对象引用Person.prototype.getName = function() &#123; return this.name;&#125;;Person.prototype.getAge = function() &#123; return this.age;&#125;;// 注意如果用对象字面量的形式创建，`constructor`的指向会改变。 这里我们把函数Person称为构造函数，也就是创建自定义对象的函数。可以看出，JavaScript通过构造函数和原型的方式模拟实现了类的功能。创建自定义对象（实例化类）的代码：123var zhangsan = new Person('zhangsan', 25, 'male');console.log(zhangsan.getName()); // zhangsanconsole.log(zhangsan.constructor == Person); // true Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。而实例会有一个constructor属性指向它们的构造函数。 isPrototypeOf()这个方法可以来判断某个prototype对象和某个实例间的关系。1console.log(Person.prototype.isPrototypeOf(zhangsan)); // true hasOwnProperty()用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 12console.log(zhangsan.hasOwnProperty(&apos;name&apos;)); // trueconsole.log(zhangsan.hasOwnProperty(&apos;getName&apos;)); // false 继承现在有2个构造函数：1234567function Parent(name) &#123; this.name = name;&#125;function Child(age) &#123; this.age = age;&#125; 如何让Child继承name？ 构造函数继承使用call或apply方法，将父对象的构造函数绑定在子对象上。 1234567891011function Parent(name) &#123; this.name = name;&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;var anni = new Child('anni', 12);anni.name // anni prototype模式如果Child的prototype对象，指向一个Parent的实例，那么所有Child的实例，就能继承Parent了。 1234Child.prototype = new Parent();Child.prototype.constructor = Child;//让构造函数指回Child，而不是Parentvar jack = new Child('jack', 22);jack.name ;// jack 空对象中介其实原理依然是prototype。直接继承至Parent.prototype。 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 非构造函数12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 拷贝123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 参考资料：http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.htmlhttps://segmentfault.com/a/1190000002440502http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript闭包学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-closure.html</url>
      <content type="text"><![CDATA[闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为函数是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。 什么是闭包闭包的定义非常晦涩 闭包，是指语法域位于某个特定的区域，具有持续参照（读写）位于该区域内自身范围之外的执行域上的非持久型变量值能力的段落。这些外部执行域的非持久型变量神奇地保留它们在闭包最初定义（或创建）时的值（深连结）。 简单来说，闭包就是在另一个作用域中保存了一份它从上一级函数或作用域取得的变量（键值对），而这些键值对是不会随上一级函数的执行完成而销毁。如果一个函数访问了它的外部变量，那么它就是一个闭包。 注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。 闭包的作用 可以读取函数内部的变量。(保护函数内的变量安全) 让这些变量的值始终保持在内存中。 1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 makeAdder执行完以后变量x的值始终存在内存中，没有被回收。内部函数运行依赖外部函数的变量x。 例子：123456789101112131415var singleton = function () &#123; var privateVariable; function privateFunction(x) &#123; ...privateVariable... &#125; return &#123; firstMethod: function (a, b) &#123; ...privateVariable... &#125;, secondMethod: function (c) &#123; ...privateFunction()... &#125; &#125;;&#125;(); 这个单件通过闭包来实现。通过闭包完成了私有的成员和方法的封装。匿名主函数返回一个对象。对象包含了两个方法，方法1可以方法私有变量，方法2访 问内部私有函数。需要注意的地方是匿名主函数结束的地方的’()’，如果没有这个’()’就不能产生单件。因为匿名函数只能返回了唯一的对象，而且不能被 其他地方调用。这个就是利用闭包产生单件的方法。 理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。 参考资料http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.htmlhttp://www.oschina.net/question/28_41112http://www.jb51.net/article/18303.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript构造函数学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-constructor.html</url>
      <content type="text"><![CDATA[JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过new关键字方式调用的函数都被认为是构造函数。 构造函数123456function Person(name) &#123; this.name = name;&#125;var jack = new Person('杰克'); // 当这一句代码结束,你就可以肯定的认为 // Person 函数是一个构造函数,因为它 new 了"杰克" 不是所有函数都是构造函数, 只有 new 出实例的函数才是构造函数.实例对象jack被构造函数 Person 实例化之后,它就有一个属性constructor,此属性是一个指针,指向构造函数 (告诉我们是谁创造了它)同时,实例对象jack初始化以后同时有了一个只读属性__proto__ ,这个指针指向了原型对象. jack.__proto__ === Person.prototype这是一定成立的. 除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object) 。原型对象存放于 ConstructorFunction.prototype 属性中。 原型介绍请看JavaScript原型学习笔记 参考资料https://bonsaiden.github.io/JavaScript-Garden/zh/#function.constructorshttp://www.nowamagic.net/librarys/veda/detail/1642http://yijiebuyi.com/blog/7193e9e04fa01c4d7c05ec5b29494d9d.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript作用域学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-scope.html</url>
      <content type="text"><![CDATA[作用域是JavaScript最重要的概念之一，想要学好JavaScript就需要理解JavaScript作用域和作用域链的工作原理。 JavaScript作用域任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。 变量作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。在ES6之前，局部变量只能存在于函数体中，并且函数的每次调用它们都拥有不同的作用域范围。 局部变量只能在其被调用期的作用域范围内被赋值、检索、操纵。 需要注意，在ES6之前，JavaScript不支持块级作用域，这意味着在if语句、switch语句、for循环、while循环中无法支持块级作用域。 也就是说，ES6之前的JavaScript并不能构建类似于Java中的那样的块级作用域（变量不能在语句块外被访问到）。但是， 从ES6开始，你可以通过let关键字来定义变量，它修正了var关键字的缺点，能够让你像Java语言那样定义变量，并且支持块级作用域。 JavaScript的作用域链JS权威指南中有一句很精辟的描述: ”JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.” 1234567891011var name = 'laruence';function echo() &#123; console.log(name);&#125;function env() &#123; var name = 'eve'; echo();&#125;env(); // laruence 作用域链是一个对象列表或链表。这组对象定义了这段代码“作用域中”的变量。 在JS中，作用域的概念和其他语言差不多， 在每次调用一个函数的时候 ，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域. JS的语法风格和C/C++类似, 但作用域的实现却和C/C++不同，并非用“堆栈”方式，而是使用列表，具体过程如下(ECMA262中所述): 任何执行上下文时刻的作用域, 都是由作用域链(scope chain)来实现。 在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性。 在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 然后对于每一个函数的形参，都命名为该活动对象的属性, 然后将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中。 123456function add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125;var total = add(5,10); 注意，全局执行环境的变量对象(window)始终都是作用域链的最后一个对象。 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 参考资料http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.htmlhttp://www.laruence.com/2009/05/28/863.htmlhttp://wwsun.github.io/posts/scope-and-context-in-javascript.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript原型学习笔记]]></title>
      <url>%2FFontEnd%2Fjs-prototype.html</url>
      <content type="text"><![CDATA[Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。 JavaScript 不包含传统的类继承模型，而是使用 prototype原型模型。虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 什么是原型？原型是一个对象，通过原型可以实现对象的属性继承。而对象是若干个无序属性的集合。对象的属性为字符串。 那些对象有原型所有的对象在默认的情况下都有一个原型，因为原型本身也是对象，所以每个原型自身又有一个原型(只有一种例外，默认的对象原型在原型链的顶端。即Object.protorype)。 认识原型在JavaScript的对象中都包含了一个”[[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。“[[Prototype]]”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了__proto__这个非标准（不是所有浏览器都支持）的访问器（ECMA引入了标准对象原型访问器Object.getPrototypeOf(object)）。在JavaScript的原型对象中，还包含一个constructor属性，这个属性对应创建所有指向该原型的实例的构造函数。 方法方法这个特殊的对象除了和其他对象一样有__proto__属性之外，还有自己特有的属性——原型属性（prototype）。这个属性是一个指针，指向一个对象。这个对象的用途是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含一个指针，指回原构造函数. 任何一个对象都有constructor属性，指向创建这个对象的构造函数。 隐式原型（__proto__）指向创建这个对象的函数的prototype。 1234567891011121314151617181920212223242526272829303132333435function Foo(y)&#123; this.y = y;// 构造函数将会以特定模式创建对象：被创建的对象都会有"y"属性&#125;Foo.prototype.x = 10;Foo.prototype.calculate = function(z) &#123; return this.x + this.y + z;&#125;;var b = new Foo(20);var c = new Foo(30);console.log(b.calculate(30)); // 10 + 20 + 30 = 60console.log(c.calculate(50)); // 10 + 30 + 50 = 90// 让我们看看是否使用了预期的属性console.log( b.__proto__ === Foo.prototype, // true c.__proto__ === Foo.prototype, // true // "Foo.prototype"自动创建了一个特殊的属性"constructor" // 指向a的构造函数本身 // 实例"b"和"c"可以通过授权找到它并用以检测自己的构造函数 b.constructor === Foo, // true c.constructor === Foo, // true Foo.prototype.constructor === Foo // true b.calculate === b.__proto__.calculate, // true b.__proto__.calculate === Foo.prototype.calculate // true); 原型链如果一个原型对象的原型不为null的话，我们就称之为原型链。 属性查找当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined。例子：1234567891011121314151617function foo() &#123; this.add = function (x, y) &#123; return x + y; &#125;&#125;foo.prototype.add = function (x, y) &#123; return x + y + 10;&#125;Object.prototype.subtract = function (x, y) &#123; return x - y;&#125;var f = new foo();console.log(f.add(1, 2)); //结果是3，而不是13console.log(f.subtract(1, 2)); //结果是-1 属性在查找的时候是先查找自身的属性，如果没有再查找原型，再没有，再往上走，一直查到Object的原型上。 再上一张图来表示__proto__和prototype的关系。 参考文献http://www.nowamagic.net/librarys/veda/detail/1648http://www.jb51.net/article/80109.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSSOM视图模式介绍]]></title>
      <url>%2FFontEnd%2Fjs-cssom-view-module.html</url>
      <content type="text"><![CDATA[Window视图属性这些属性可以获取住整个浏览器窗体大小。 innerWidth 属性和 innerHeight 属性 pageXOffset 属性和 pageYOffset 属性 screenX 属性和 screenY 属性 outerWidth 属性和 outerHeight 属性 innerWidth属性和innerHeight属性innerWidth表示获取window窗体的内部宽度，不包括用户界面元素,浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。示例代码：12window.innerWidthwindow.innerHeight 兼容性：不支持IE6/7/8，innerWidth和innerHeight属性只读，没有默认值。 outerWidth属性和outerHeight属性outerWidth/outerHeight表示整个浏览器窗体的大小，包括所有界面元素（如工具栏/滚动条）。 示例代码：12window.outerWidthwindow.outerHeight 兼容性：不支持IE6/7/8，outerWidth和outerHeight属性只读，没有默认值。 区别如图： pageXOffset属性和pageYOffset属性pageXOffset和pageYOffset，表示整个页面滚动的像素值（水平方向的和垂直方向的）。 示例代码：12window.pageXOffsetwindow.pageYOffset 兼容性：不支持IE6/7/8，pageXOffset和pageYOffset属性只读，没有默认值。 screenX属性和screenY属性浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。 示例代码：12window.screenXwindow.screenY 兼容性：不支持IE6/7/8，IE低版本浏览器使用window.screenLeft 和 window.screenTop可获得相同的值。 Screen视图属性指能获取显示器信息的一些属性。 availWidth 属性和 availHeight 属性 colorDepth 属性 pixelDepth 属性 width 属性和 height 属性 availWidth属性和availHeight属性显示器可用宽高，不包括任务栏之类的。 示例代码：12screen.avialWidthscreen.avialHeight 兼容性良好。 colorDepth属性表示显示器的颜色深度。 示例代码：1screen.colorDepth 兼容性：主浏览器都支持返回24，IE6/7/8返回32。 pixelDepth该属性基本上与colorDepth一样。低版本IE不支持。 width和height表示显示器屏幕的宽高。 示例代码：12screen.widthscreen.height 兼容性良好。 文档视图(DocumentView)和元素视图(ElementView)方法四个方法：1234elementFromPoint()getBoundingClientRect()getClientRects()scrollIntoView() elementFromPoint()方法返回给定坐标处所在的元素。 示例代码：1document.elementFromPoint(x,y) 兼容性：不过位置坐标不太一样，浏览器还是有差异的。 getBoundingClientRect()方法得到矩形元素的界线，返回的是一个对象，包含top,left,right,和bottom四个属性值，大小都是相对于文档视图左上角计算而来。 示例代码：1element.getBoudingClientRect() 兼容性良好。 getClientRects()方法返回元素的数个矩形区域，返回的结果是个对象列表，具有数组特性。这里的矩形选区只针对inline box，因此，只针对a,span,em这类标签元素，这个下面会详细讲述。 兼容性：IE6/7有bug，其他支持。 scrollIntoView()方法让元素滚动到可视区域（不属于草案方法），类似锚点跳转功能页面定位。 示例代码：1element.scrollIntoView() 兼容性良好。 元素视图属性(Element)关于元素大小位置等信息的一些属性。有：clientLeft和clientTopclientWidth和clientHeightoffsetLeft和offsetTopoffsetParentoffsetWidth和offsetHeightscrollLeft和scrollTopscrollWidth和scrollHeight clientLeft属性和clientTop属性表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。 示例代码：12obj.clientLeftobj.clientTop 兼容性良好。 clientWidth属性和clientHeight属性表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。 示例代码：12obj.clientWidthobj.clientHeight 兼容性良好。 offsetLeft属性和offsetTop属性表示相对于最近的祖先定位元素（CSS position 属性被设置为relative、absolute或fixed的元素）的左右偏移值。 12obj.offsetLeftobj.offsetTop 兼容性良好。 offsetParent属性第一个祖定位元素（即用来计算上面的offsetLeft和offsetTop的元素）。offsetParent元素只可能是下面这几种情况： &lt;body&gt; position不是static的元素 &lt;table&gt;,&lt;th&gt;或&lt;td&gt;，但必须要position: static。 1obj.offsetParent 兼容性良好。 offsetWidth属性和offsetHeight属性整个元素的尺寸（包括边框）。 示例代码：12obj.offsetWidthobj.offsetHeight 兼容性良好。 scrollLeft属性和scrollTop属性表示元素滚动的像素大小。 示例代码：12obj.scrollLeftobj.scrollTop 兼容性良好。 例子：元素位置(绝对)12obj.getBoundingClientRect().left + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);obj.getBoundingClientRect().top + Math.max(document.documentElement.scrollTop, document.body.scrollTop); scrollWidth属性和scrollHeight属性表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。 兼容性：不理想。 鼠标位置(Mouse position)相关的些属性有：clientX,clientYoffsetX,offsetYpageX,pageYscreenX,screenYx,y clientX和clientY相对于window，为鼠标相对于window的偏移,不包括滚动条。 示例代码：12event.clientXevent.clientY 兼容性良好。 offsetX和offsetY表示鼠标相对于当前被点击元素padding box的左上偏移值。 示例代码：12event.offsetXevent.offsetY 兼容性：不理想。 pageX和pageY为鼠标相对于document的坐标。包括滚动条的偏移。 示例代码：12event.pageXevent.pageY 兼容性：IE6/7/8不支持。 screenX和screenY鼠标相对于显示器屏幕的偏移坐标。 示例代码：12event.screenXevent.screenY 兼容性良好。 结语上面陆续出现的属性或方法，那些兼容性不错的东西我们可以多多关注下。很多特性都是非常实用的。例如：1234567getBoundingClientRect()scrollIntoView()clientWidth和clientHeightoffsetLeft和offsetTopoffsetWidth和offsetHeightscrollLeft和scrollTopclientX和clientY]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017 新的开始]]></title>
      <url>%2Flife%2Fhello-2017.html</url>
      <content type="text"><![CDATA[新的一年刚刚开始，一转眼就毕业好多年了，2016年似乎一眨眼的功夫就过去了。2016年认真开始转行，进度甚微，经历了从开始到放弃又重新开始，失望、沮丧、苦涩等各种心境，2016最终熬过去了。希望2017年能够有一个新的开始，能够真正的充实的过好每一天，day day up！ 博客今年入驻了github，新的一年搭建了自己的博客，以后要坚持每周一篇博客，记录自己遇到的问题和经历。坚持一些自己喜欢的事情，希望既能帮助自己也能帮助他人。 github去年底开始学习前端，于是注册了github，从刚开始的什么都不懂，到慢慢的能够写一些简单的代码，很开心。编程真的是很有趣，看到自己写的代码运行起来，展示在自己和他人面前，非常有成就感。新的一年要在github上面投入更多的时间和精力，向里面的大神学习，写自己的项目，点满每一天，为github社区贡献一些自己的东西。 新年计划 今年看到了一些有趣的书籍，余华、王小波等，2017年想看更多的书籍，定个小目标20本。 加强自己沟通的能力，解决问题的能力，每天坚持写代码。 坚持健身，争取把腹肌给练出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>%2Ffirst%2Fhello-world.html</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
